<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[Android代码性能优化(Android Developer Training翻译)]]></title>
      <url>%2F2017%2F03%2F22%2FAndroid%E4%BB%A3%E7%A0%81%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96(Android%20Developer%20Training%E7%BF%BB%E8%AF%91)%2F</url>
      <content type="text"><![CDATA[本文翻译自Android官方training:https://developer.android.google.cn/training/articles/perf-tips.html 说到代码性能优化，选择合适的算法和数据结构应该永远是我们首先要考虑的，我们在此并不讨论这个。本文讨论的是可以提升app整体性能的代码优化方法，它们可能并不总能那么显著地提升整个app的性能，但是你可以将这些技巧融入你的编程习惯中，从而使你写出更高效的代码。 对于写出更高效的代码，有两个基本原则： 避免做你不需要做的事情 避免分配多余的内存 你必须对Android代码的每一个细节做优化的一个原因是：你的代码将运行在多种多样的硬件设备上。不同的处理器，不同虚拟机，不同的运行速度。你甚至不能简单地说一个设备肯定比另一个设备快。对于不同的设备来说，是否有JIT会造成很大的不同，对有JIT设备优化得最好的代码并不一定适合于没有JIT的设备。 为了确保你的app能够在跨平台多设备上都表现得都很好，需要保证在所有层级上优化你的代码。 避免创建不必要的对象对象的创建从来都不是免费的，它需要消耗系统的资源。 当应用程序内存中的对象达到一定数量时，系统将强制开始进行GC，这时设备会发生短暂卡顿，从而影响用户体验。 在Android 2.3中引入了并行垃圾收集器有助于缓解这个问题，但我们应该总是要避免不必要的内存分配。 因此，应避免创建不需要的对象实例。 以下是一些样例建议： 如果你的方法返回一个String，而这个返回的String总是要拼接成一个StringBuffer，那么，你应该改变的方法签名和返回，在方法中直接拼接StringBuffer，而不是创建一个生命周期很短的临时String变量。 当你需要从输入数据中提取字符串的时候，使用substring而不是创建一个输入数据的拷贝，这样你将创建一个String对象，但是这个String对象将和输入数据共享常量char字符数组。（这样做的代价是如果你只需要提取输入数据的一小部分，最终你也必须在内存中保留整个输入数据） 有个更激进的想法是：用一维的数组替换多维数组 int数组比Integer要高效得多，两个元素一一对应的int数组依然比一个Object&lt;int,int&gt;数组高效得多。对于其他基本类型来说也是这样的。 如果你需要一个元祖tuples(Foo,Bar)对象，记住使用两个平行的元素一一对应的Foo[]和Bar[]将总是比创建一个Object&lt;Foo, Bar&gt;数组来的高效得多。（有一个例外是，当你设计API提供给其他代码调用的时候，为了实现良好的规范，你应该对这个优化做妥协） 一般来说，要尽量避免创建短期的临时变量，这样能够减少影响用户体验的垃圾收集器的GC的频率。 使用Static替代Virtual如果你的方法不需要访问对象的成员字段，那将其设置为static，这样的话方法的调用速度会提升15%~20%。同时这也是良好的代码实践，因为你能够通过static修饰符知道这个方法不会改变对象的状态。 使用Static Final修饰常量考虑如下在一个类的顶部的两个声明： 12static int intVal = 42;static String strVal = "Hello, world!"; 编译器生成了一个初始化方法叫&lt;clinit&gt;，当变量第一次被引用的时候会调用这个方法。这个方法存储了intVal和42、strVal和”Hello, world!”的对应关系。当这两个变量被引用的时候，系统通过成员字段域查找来得到这两个变量的值。 我们可以使用关键字final来改变这种状况： 12static final int intVal = 42;static final String strVal = "Hello, world!"; 这样这个类就不需要&lt;clinit&gt;方法了，因为常量直接被编译到dex文件中，被引用的intVal将直接被替换成42，strVal也被直接替换成字符串常量，而不需要查找成员字段域。 避免内部的Getters/Setters访问器在类似C++的语言中，使用Getters/Setters而不是成员字段是通用的代码实践。这个对C++来说很好的实践也经常被应用于其他面向对象语言比如C#和Java，因为编译器总是能够内联优化代码，而如果你需要限制或者调试成员字段，你可以在任何时候更改Getters/Setters内的代码来实现。 然而，对Android来说，这并不是一个好主意。方法的调用比成员字段域查找要昂贵得多。公开的接口是有必要按照面向对象的法则声明getters和setters的，但是在类内部，你应该总是直接使用成员字段本身。 没有JIT的时候，直接的成语变量访问会比使用一个不必要的getter方法快3倍，如果有JIT，那么会快7倍（有JIT的时候访问成员字段和访问局部变量几乎是同等的低消耗）。 使用增强的循环语法(for-each)增强的循环语法（有时候也常常叫做for-each循环）可以被任何实现了Iterable接口的对象集合使用。当循环ArrayList的时候，一个手写的计数循环会比for-each循环快3倍左右(无论是否有JIT)，但是对其他集合collections来说，for-each循环几乎和使用iterator循环来得一样快。 对于数组循环来说，有以下几种选择： 1234567891011121314151617181920212223242526272829static class Foo &#123; int mSplat;&#125;Foo[] mArray = ...public void zero() &#123; int sum = 0; for (int i = 0; i &lt; mArray.length; ++i) &#123; sum += mArray[i].mSplat; &#125;&#125;public void one() &#123; int sum = 0; Foo[] localArray = mArray; int len = localArray.length; for (int i = 0; i &lt; len; ++i) &#123; sum += localArray[i].mSplat; &#125;&#125;public void two() &#123; int sum = 0; for (Foo a : mArray) &#123; sum += a.mSplat; &#125;&#125; zero()是最慢的，因为JIT不能优化通过循环的每次迭代获得数组长度一次的成本,即每一次循环都需要计算一遍mArray.length。 one()更快一些。它将所有内容都放到局部变量中，避免重复计算。但是只有len的计算优化了性能。 对于没有JIT的设备，two()是最快的，并且与具有JIT的设备无法区分。 它使用了Java1.5版本中引入的增强型for循环语法。 因此，对于ArrayList循环，如果你对性能非常敏感的话，可以考虑一个手写的计数循环。除此之外，您应该默认使用增强型for循环。 提示：另请参见Josh Bloch的《 Effective Java》第46条。 考虑使用包替代私有内部类对外部类的私有域的访问考虑以下声明： 12345678910111213141516171819public class Foo &#123; private class Inner &#123; void stuff() &#123; Foo.this.doStuff(Foo.this.mValue); &#125; &#125; private int mValue; public void run() &#123; Inner in = new Inner(); mValue = 27; in.stuff(); &#125; private void doStuff(int value) &#123; System.out.println("Value is " + value); &#125;&#125; 这里我们定义一个私有内部类（Foo$Inner），它直接访问外部类中的私有方法和私有实例字段。 对于Java语言语法来说，这是合法的，代码打印“Value is 27”符合预期。 但是问题是虚拟机认为从Foo$Inner直接访问Foo的私有成员是非法的，因为Foo和Foo$Inner是两个不同的类，即使Java语言允许内部类访问外部类的私有成员。 为弥合这个差距，编译器生成了几个合成方法： 123456/*package*/ static int Foo.access$100(Foo foo) &#123; return foo.mValue;&#125;/*package*/ static void Foo.access$200(Foo foo, int value) &#123; foo.doStuff(value);&#125; 内部类代码在需要访问mValue字段或调用外部类中的doStuff()方法时调用这些静态方法。 这意味着，上面的代码会归结为通过访问器方法访问成员字段的情况。 前面我们讨论了访问器如何比直接字段访问慢，所以这是一个因为特定语言语法导致“隐形”性能问题的例子。 如果你在对性能要求严格的场景中使用这样的代码，你可以通过改变内部类访问的字段和访问的访问的权限为包访问，而不是私有访问，从而避免上述开销。 但是这意味着字段可以被同一个包中的其他类直接访问，所以你不应该在公共API中使用它——因此最佳的方法是使用包替代私有内部类对外部类的私有域的访问。 避免使用Float根据经验，浮点数在Android设备上比整数慢两倍。 在速度方面，在更现代的硬件上float和double几乎没有区别。 在存储空间方面，double是Float的2倍大。 和PC一样，假设存储空间不是问题，你应该偏向使用double。 此外，即使对于整数，一些处理器具有硬件乘法，但是缺少硬件除法。 在这种情况下，整数除法和模数运算会在软件中执行，想想你在设计一个哈希表或做大量的数学计算(这将消耗大量的系统资源)——因此我们也应该尽量避免除法运算或者将它转换成乘法运算。 熟悉和使用库使用系统库代码，除了有那些我们熟知的好处之外，记住，系统可以使用底层汇编方法优化代码。 这里典型的例子是String.indexOf()和相关的API，Dalvi使用了一个内联的内在替换(提高了性能)。 类似地，System.arraycopy()方法比使用JIT的Nexus One上的手写的编码循环快大约9倍。 提示：另见Josh Bloch的《Effective Java》，第47条。 谨慎使用Native方法使用Android NDK开发具有Native代码的应用程序不一定比使用Java语言编程更有效。首先，存在与Java代码转换的相关成本，并且JIT不能跨越这些边界进行优化。如果您分配了本机资源（本机堆上的内存，文件描述符或任何内容），那么安排这些资源的及时回收会更加困难。你还需要编译你想要运行的每个架构的代码（而不是依赖一个JIT）。你甚至可能需要为你认为相同的架构编译多个版本：为G1中的ARM处理器编译的Native代码不能充分利用Nexus One中的ARM，而为Nexus One中的ARM编译的代码将不能在G1上的ARM上运行。 Native代码主要用于当你有一个现有的Native代码库，你想要移植到Android，而不是用于“加速”使用Java语言编写的Android应用程序的部分。 如果你确实需要使用Native代码，你应该阅读我们的JNI提示。 提示：另见Josh Bloch的《Effective Java》第54条。 性能神话在没有JIT的设备上，通过具有确切类型的变量而不是接口调用方法稍微更高效些。(例如，使用HashMap声明map会比使用Map声明map来的更高效，即使在这两种情况下映射的都是HashMap对象）这里的区别并不会夸张到一种比另一种慢两倍这么大，实际差异更像是慢6％这么多。 此外，有JIT的话，这两者的效率几乎相同。 在没有JIT的设备上，缓存成员字段访问比重复访问成员字段快约20％。 使用JIT，成员字段访问成本大约与本地字段访问成本相同，因此这不是一个值得优化的地方，除非你觉得它使你的代码更容易阅读。 （对于 final, static和static final修饰的成员字段也是如此）。 比较优化效果在开始优化之前，请确保您有一个需要解决的问题。 确保您可以准确地衡量您现有的绩效，否则您将无法衡量您尝试的替代方案的优势。 您也可能发现Traceview对于分析有用，但是重要的是要意识到它当前禁用了JIT，这可能导致它错误地将时间归因于使用JIT可能提升性能的代码。 在进行Traceview数据建议的更改后，确保生成的代码在没有Traceview的情况下运行更快时尤其重要。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[设计模式六大原则]]></title>
      <url>%2F2017%2F02%2F20%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%85%AD%E5%A4%A7%E5%8E%9F%E5%88%99%2F</url>
      <content type="text"><![CDATA[概要 单一职责原则：类的职责要单一； 里氏替换原则：不要破坏继承体系； 依赖倒置原则：要面向接口编程； 接口隔离原则：设计接口的时候要精简单一； 迪米特法则：高内聚，低耦合； 开闭原则：要对扩展开放，对修改关闭。 单一职责原则（Single Responsibility Principle）定义 一个类只负责一项职责，不要存在多于一个导致类变更的原因。 优点 可以降低类的复杂度，一个类只负责一项职责，其逻辑肯定要比负责多项职责简单的多。 提高类的可读性，提高系统的可维护性。 变更引起的风险降低，变更是必然的，如果单一职责原则遵守的好，当修改一个功能时，可以显著降低对其他功能的影响。 说明 理想情况下，我们希望单一原则能够被所有的单元遵守，每个包，类，方法都有单一的职能归属，这在前期需求确定下的设计也都是可以实现的。实际项目中，需求不断增加和变动导致的整体结构的重新设计几乎是不可避免的，当项目代码达到一定量级的时候，很简单的单一原则有时候遵守起来却代价巨大，这时候就需要考虑投入和产出的关系了。当然，最基本要做的就是最开始设计的时候遵循单一原则，并且定期重构代码，这样在需求变动后改动起来会方便很多。 实现 实际开发中，遵守每个包，类，方法都有单一的职能归属的原则。 里氏替换原则（Liskov Substitution Principle）定义 在使用基类的的地方可以任意使用其子类，能保证子类完美替换基类。 如果在使用A的地方都可以使用B，那么B是A的子类型。 优点 里氏替换原则实际上体现了子类和父类的关系的含义，有助于在开发理清各个类之间的关系，从而做出更好的设计，同时在需求变更时降低系统出错率。 增强程序的健壮性，即使增加了子类，原有的子类还可以继续运行。 说明 如果子类不能完整地实现父类的方法，或者父类的某些方法在子类中已经发生“畸变”，则建议断开父子继承关系 采用依赖、聚合、组合等关系代替继承。 继承包含这样一层含义：父类中凡是已经实现好的方法，实际上是在设定一系列的规范和契约，虽然它不强制要求所有的子类必须遵从这些契约，但是如果子类对这些非抽象方法任意修改，就会对整个继承体系造成破坏。而里氏替换原则就是表达了这一层含义。 实现 子类可以实现父类的抽象方法，但不能覆盖父类的非抽象方法。 子类中可以增加自己特有的方法。 当子类的方法重载父类的方法时，方法的形参要比父类方法的输入参数更宽松。 当子类的方法实现父类的抽象方法时，方法的返回值要比父类更严格。 依赖倒置原则（Dependence Inversion Principle）定义 高层模块不应该依赖底层模块，二者都该依赖其抽象。 抽象不应该依赖细节；细节应该依赖抽象。 优点 依赖倒置使得调用端在开发时无需关注底层支持模块的具体实现，而只需要关注如何调用。 在设计好接口后，调用端和底层支持的具体实现模块可以并行开发，提高效率。 TDD开发模式就是依赖倒置原则最成功的应用。 说明 高层模块就是调用端，低层模块就是具体实现类。抽象就是指接口或抽象类。细节就是实现类。 依赖倒置原则的本质就是通过抽象（接口或抽象类）使个各类或模块的实现彼此独立，互不影响，实现模块间的松耦合。 实现 低层模块尽量都要有抽象类或接口，或者两者都有。 变量的声明类型尽量是抽象类或接口。 使用继承时遵循里氏替换原则。 接口隔离原则（Interface Segregation Principle）定义 类间的依赖关系应该建立在最小的接口上，调用方不应该依赖和实现它不需要的接口。 优点 类的功能更清晰，且减少冗余 接口设计更灵活，易于拓展和修改 实现 建立单一接口，不要建立庞大臃肿的接口，尽量细化接口，接口中的方法尽量少。为各个类建立专用的接口，而不要试图去建立一个很庞大的接口供所有依赖它的类去调用。 接口尽量小，但是要有限度。对接口进行细化可以提高程序设计灵活性，但是如果过小，则会造成接口数量过多，使设计复杂化。 为依赖接口的类定制服务。只暴露给调用的类它需要的方法，它不需要的方法则隐藏起来。只有专注地为一个模块提供定制服务，才能建立最小的依赖关系。 迪米特法则（Law of Demeter）定义一个类对自己依赖的类知道的越少越好。也就是低耦合，高内聚。 优点 单个模块的职责分明。 利于并行开发，各模块间不互相影响。 说明 无论是面向过程编程还是面向对象编程，只有使各个模块之间的耦合尽量的低，才能提高代码的复用率。 应该明确每个类的职责，不应该把”多余”的任务交给负责其他职责的类。将职责划分清楚后，由不同的模块和类来实现。 实现 明确每个类的职责，实现良好的任务分配。 开放封闭原则（Open Close Principle）定义 一个软件实体如类、模块和函数应该对扩展开放，对修改关闭。 当软件需要变化时，尽量通过扩展软件实体的行为来实现变化，而不是通过修改已有的代码来实现变化。 优点 对扩展开放意味着要编写可扩展的代码，适应需求变化。 对修改关闭的好处是不修改原有代码的逻辑，不容易通过修改代码使原有业务逻辑发生变化。 说明 开放封闭原则是对设计的一个很高的要求，既要可扩展，易扩展，又要对修改封闭，扩展时不影响原有代码和逻辑。这实际上是我们设计的目标。 装饰模式很好地体现了开放封闭原则。 实现 遵循以上5个原则。 充分理解需求，考虑业务逻辑将来可能会发生的变动和拓展。 总结设计模式的六大原则是在大量的编程实践中总结出来的良好的设计规范，它更偏向于设计建议而不是定死的规则。在设计中，应该结合实际项目考虑遵循这些规范的程度，不要为了设计而设计。 总结一句话就是：所有的设计原则和规范都是以更高效的开发产出为目标的，遵循任何原则和规范之前都最好考虑一下投入产出比，一切为了更高效的开发服务。 参考资料 http://www.jianshu.com/p/807bc228dbc2http://www.uml.org.cn/sjms/201211023.asp]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[成功的git分支模型]]></title>
      <url>%2F2016%2F12%2F20%2F%E6%88%90%E5%8A%9F%E7%9A%84git%E5%88%86%E6%94%AF%E6%A8%A1%E5%9E%8B%2F</url>
      <content type="text"><![CDATA[最近看了一篇文章，讲到如何构建一个成功的git分支模型，下面说说我对git分支模型的理解。 分支策略 master 单个分支。 线上代码分支，不进行直接开发。 代码的改变来源于release分支和hotfixes分支的merge。 每次merge产生一个Tag并发布线上版本，每个Tag表示每一个线上运行的app版本的真实完全代码。 develop分支 单个分支。 主要开发分支，代码提交最多的分支。 若release的代码需要功能性的修改，则将release的代码merge到develop重新开始开发。 若开发时需要并行开始一个耗时较长的功能开发，根据需要，可将develop分支check out到特定新功能分支feature来进行开发，当feature开发完成，再merge到develop中。 feature分支 多个分支，命名feature_some_function。 每次需要新的花时较长且和原develop代码耦合较低的功能并行开发时，可开启一个新的feature分支。 feature分支同样应具有feature master和feature develop。 feature分支开发完成后merge到develop分支。 release分支 多个分支，命名release_version_code。 开发版本分支，当develop的功能开发完成，从develop分支check out一个新的release_version_code分支。 release只能有bug fix的代码提交，而不能有功能性需求的代码提交。 在release上时，若有bug fix之外的需求，则merge代码到develop重新开始开发，待开发完毕，merge回release。 若release代码开发完毕，merge到master上，打Tag，发布新版app，并且merge到develop,保证已修复的bug在开发分支也生效。 hotfixes分支 根据需要决定是单个还是每次热修复开新的分支。 当线上版本发生问题，需要紧急解决时，从master分支check out一个新分支，开始热修复。 若紧急修复成功，则修复完成merge到master分支，打Tag，发布新版本。 若未能热修复成功，则将代码merge到develop中，此时相当于开始一个新版本的开发流程。 总结这种分支模型总结了我们原本常用的分支策略，各分支功能划分清晰，利于代码和版本管理，提高了分工合作的效率。实际开发中，最好在每次check out新的release以及在master上打Tag时，告知每个开发人员。另外，配合上每个分支的持续集成，可将每次merge的出错率降低。 参考资料 http://nvie.com/posts/a-successful-git-branching-model]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[HashSet、HashMap、HashTable源码分析]]></title>
      <url>%2F2016%2F12%2F05%2FHashSet%E3%80%81HashMap%E3%80%81HashTable%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%2F</url>
      <content type="text"><![CDATA[本文基于Android6.0源码分析 HashSetHashSet常用于存储无重复的值。 HashSet内部实现： 123public HashSet() &#123; this(new HashMap&lt;E, HashSet&lt;E&gt;&gt;());&#125; 说明HashSet内部实际上是key为自身的value，而value为自身的hashmap来实现存储的，HashSet能够实现非重复存储的功能是通过HashMap来实现的，所以直接看HashMap。 HsahMapHashMap是key-&gt;value字典格式的数据结构 先来看看HashMap的构造函数： 123456transient HashMapEntry&lt;K, V&gt;[] table;public HashMap() &#123; table = (HashMapEntry&lt;K, V&gt;[]) EMPTY_TABLE; threshold = -1; // Forces first put invocation to replace EMPTY_TABLE &#125; 从HashMap的构造函数可以看到，HashMap内部实际上是通过table来存储数据的，而table是一个HashMapEntry数组。 看看HashMap最重要的函数put 12345678910111213141516171819202122232425262728293031323334@Override public V put(K key, V value) &#123; if (key == null) &#123; return putValueForNullKey(value); &#125; //根据key获取hash int hash = Collections.secondaryHash(key); HashMapEntry&lt;K, V&gt;[] tab = table; //根据hash找到数据的index int index = hash &amp; (tab.length - 1); //遍历这个index下的链表 for (HashMapEntry&lt;K, V&gt; e = tab[index]; e != null; e = e.next) &#123; if (e.hash == hash &amp;&amp; key.equals(e.key)) &#123; preModify(e); V oldValue = e.value; e.value = value; return oldValue; &#125; &#125; //没有key，存新的值 modCount++; if (size++ &gt; threshold) &#123; tab = doubleCapacity(); index = hash &amp; (tab.length - 1); &#125; addNewEntry(key, value, hash, index); return null;&#125; //可以看到hashmap存新值就是往table中插入一个新的值void addNewEntry(K key, V value, int hash, int index) &#123; table[index] = new HashMapEntry&lt;K, V&gt;(key, value, hash, table[index]);&#125; 从上面的代码也可以看出HashMap在内存中的数组-链表式的存储结构，如下： 根据key由hash函数算出hashcode值，根据hashcode值找到HashMapEntry数组对应的index，若该index下没有值，则调用addNewEntry插入新值，否则( 发生hashcode冲突)在该index下链表尾添加新节点。 hashmap的存储结构也解释了一个问题：为什么HashSet和HashMap读取数据的复杂度数O(1),因为他是数据存储的，数组在内存中是连续的，可以根据index快速定位内存位置，HashMap的键冲突情况出现较少，链表的查找复杂度也在O(1)。 HashMap源码其他细节： 123456789101112//数组的大小是4private static final int MINIMUM_CAPACITY = 4; static final float DEFAULT_LOAD_FACTOR = .75F;//默认大小2private static final Entry[] EMPTY_TABLE = new HashMapEntry[MINIMUM_CAPACITY &gt;&gt;&gt; 1]; //threshold表示一个当前容量临界值，当当前hashmap大小超过threshold时，hashmap的capacity扩容(翻倍扩容)//threshold = capacity * DEFAULT_LOAD_FACTOR;private transient int threshold; HashMap中常用的几个成员变量 123private transient Set&lt;K&gt; keySet;//hashmap的key构成的set，可实现key遍历private transient Set&lt;Entry&lt;K, V&gt;&gt; entrySet;//hashmap键值对构成的set,可实现hashmap遍历 private transient Collection&lt;V&gt; values;//hashmap的value构成的set，可实现value遍历 HashTableHashTable的源码和HashMap很类似，只是几乎在所有函数前都加了synchronized关键字，HashTable和HashMap在使用上并没有什么不同，只是hashtable是线程安全的。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[synchronized关键字总结]]></title>
      <url>%2F2015%2F09%2F14%2Fsynchronized%E5%85%B3%E9%94%AE%E5%AD%97%E6%80%BB%E7%BB%93%2F</url>
      <content type="text"><![CDATA[Synchronized关键字的作用：当一个线程访问object的一个取得对象同步锁如synchronized(this)同步代码块时，它就获得了这个object的对象锁。这时，其它线程对该object对象所有同步代码部分的访问都被暂时阻塞。类同步锁类似。 Synchronized获得的锁分两种： 对象的锁 类的锁 Synchronized获得的锁的方式分两种： 修饰方法 修饰代码块 测试代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788public class SynchronizedTest &#123; void norFun() &#123; System.out.println("norFun"); &#125; //修饰非静态方法,取得对象锁 synchronized void syncFun() &#123; System.out.println("syncFun before"); try &#123; Thread.sleep(3000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println("syncFun after"); &#125; //修饰代码块,取得对象锁 void syncBlock() &#123; System.out.println("syncBlock before"); synchronized (this) &#123; try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; System.out.println("syncBlock after"); &#125; //修饰静态方法,取得类锁 synchronized static void staticFun() &#123; System.out.println("staticFun before"); try &#123; Thread.sleep(3000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println("staticFun after"); &#125; //修饰代码块,取得类锁 void staticBlock() &#123; System.out.println("static before"); synchronized (SynchronizedTest.class) &#123; try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; System.out.println("static after"); &#125; public static void main(String[] args) &#123; SynchronizedTest object = new SynchronizedTest(); new Thread(new Runnable() &#123; @Override public void run() &#123; object.syncFun(); &#125; &#125;).start(); new Thread(new Runnable() &#123; @Override public void run() &#123; object.syncBlock(); &#125; &#125;).start(); new Thread(new Runnable() &#123; @Override public void run() &#123; SynchronizedTest.staticFun(); &#125; &#125;).start(); new Thread(new Runnable() &#123; @Override public void run() &#123; object.staticBlock(); &#125; &#125;).start(); object.norFun(); &#125;&#125; //输出 syncFun before syncBlock before staticFun before static before norFun syncFun after staticFun after syncBlock after static after]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Java的WeakReference相关]]></title>
      <url>%2F2015%2F09%2F13%2FJava%E7%9A%84WeakReference%E7%9B%B8%E5%85%B3%2F</url>
      <content type="text"><![CDATA[什么WeakReference？ Car car = new Car(22000); 弱引用： WeakReference&lt;Car&gt; weakCar = new WeakReference&lt;Car&gt;(car); 可以这样理解：weakCar类似于car的指针，可以通过weakCar.get()得到car对象，当car对象需要被回收的时候(比如被置为null)，weakCar也会在一段时间内被系统回收。 一段测试代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253//设置-Xmx1M,即JVM堆内存最大为1M的环境运行import java.lang.ref.WeakReference;import java.util.WeakHashMap; public class Car &#123; private double price; public Car(double price) &#123; this.price = price; &#125; public double getPrice() &#123; return price; &#125; public void setPrice(double price) &#123; this.price = price; &#125; public static void main(String[] args) &#123; Car car = new Car(22000); WeakReference&lt;Car&gt; weakCar = new WeakReference&lt;Car&gt;(car); int i = 0; // 运行62332次weakCar被回收 while (true) &#123; // 如果加了这句引用强引用的car对象后weakCar就不会被回收，无限循环 // System.out.println("here is the strong reference 'car' " + car); if (weakCar.get() != null) &#123; // 使用weakCar.get()取得强引用,即使上一句if判断了也可能在这句之前被回收返回null，因此加try语句 try &#123; System.out.println("Object is alive for " + i + " loops - " + weakCar.get().getPrice()); i++; &#125; catch (NullPointerException e) &#123; e.printStackTrace(); &#125; &#125; else &#123; System.out.println("Object has been collected."); break; &#125; // 如果把car置为null，那么weakCar16次循环后被回收 //car = null; &#125; System.out.println("out of weakCar while"); // 这里用HashMap，就会产生堆内存溢出的异常，而WeakHashMap不会 WeakHashMap weakMap = new WeakHashMap&lt;Integer, byte[]&gt;(); for (int index = 0; index &lt; 10000; index++) &#123; Integer ii = new Integer(index); weakMap.put(ii, new byte[index]); System.out.println("WeakHashMap for running" + ii + "times"); &#125; &#125;&#125; 总结：一旦系统内存回收，无论内存是否紧张，弱引用指向的对象都会被回收soft reference和weak reference一样, 但被GC回收的时候需要多一个条件: 当系统内存不足时(Heap 内存是否临近阈值)，因此soft reference适合做cache object WeakHashMap：hashmap的weak版，不保证map中的键值对的存在时间，在没有调用任何赋值方法(set相关)的情况下，在一段时间后 size 方法也可能返回较小的值，对于 isEmpty 方法，返回 false，然后返回 true，对于给定的键，containsKey 方法返回 true 然后返回 false，对于给定的键，get 方法返回一个值，但接着返回 null，对于以前出现在映射中的键，put 方法返回 null，而 remove 方法返回 false，对于键集、值集、项集进行的检查，生成的元素数量越来越少。总的来说就是map中的键值对会在GC回收的时候被回收 在WeakHashMap的get(),put()函数中的getTable()方法会调用expungeStateEntries方法，以清理持有弱引用的key的表项 JVM虚拟机运行配置-Xms128m JVM初始分配的堆内存 -Xmx512m JVM最大允许分配的堆内存，按需分配 -XX:PermSize=64M JVM初始分配的非堆内存 -XX:MaxPermSize=128M JVM最大允许分配的非堆内存，按需分配]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Java垃圾回收器工作机制]]></title>
      <url>%2F2015%2F08%2F27%2FJava%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8%E5%B7%A5%E4%BD%9C%E6%9C%BA%E5%88%B6%2F</url>
      <content type="text"><![CDATA[垃圾回收机制中的算法 引用计数法无法解决循环引用，已被gc放弃 标记-清除法 由gc root往下寻找引用，将无引用的内存回收。java中可作为GC Root的对象有 虚拟机栈中引用的对象（本地变量表） 方法区中静态属性引用的对象 方法区中常量引用的对象 本地方法栈中引用的对象（Native对象） 标记-整理(压缩) 在标记清除后整理内存 复制 将活动对象复制到另一块内存中，清空这块内存 eden-&gt;Survivor0-&gt;Survivor1 分代 年轻代-年老代-持久代 年轻代： Serial收集器（复制算法) 新生代单线程收集器，标记和清理都是单线程，优点是简单高效。 ParNew收集器(停止-复制算法) 新生代收集器，可以认为是Serial收集器的多线程版本,在多核CPU环境下有着比Serial更好的表现。 Parallel Scavenge收集器(停止-复制算法) 并行收集器，追求高吞吐量，高效利用CPU。吞吐量一般为99%， 吞吐量= 用户线程时间/(用户线程时间+GC线程时间)。适合后台应用等对交互相应要求不高的场景。 年老代： Serial Old收集器(标记-整理算法) 单线程收集器，Serial收集器的老年代版本。 Parallel Old收集器(停止-复制算法) Parallel Scavenge收集器的老年代版本，并行收集器，吞吐量优先 CMS(Concurrent Mark Sweep)收集器（标记-清理算法） 高并发、低停顿，追求最短GC回收停顿时间，cpu占用比较高，响应时间快，停顿时间短，多核cpu 追求高响应时间的选择 GC的执行机制 由于对象进行了分代处理，因此垃圾回收区域、时间也不一样。GC有两种类型：Scavenge GC和Full GC。 Scavenge GC 一般情况下，当新对象生成，并且在Eden申请空间失败时，就会触发Scavenge GC，对Eden区域进行GC，清除非存活对象，并且把尚且存活的对象移动到Survivor区。然后整理Survivor的两个区。这种方式的GC是对年轻代的Eden区进行，不会影响到年老代。因为大部分对象都是从Eden区开始的，同时Eden区不会分配的很大，所以Eden区的GC会频繁进行。因而，一般在这里需要使用速度快、效率高的算法，使Eden去能尽快空闲出来。 Full GC 对整个堆进行整理，包括Young、Tenured和Perm。Full GC因为需要对整个堆进行回收，所以比Scavenge GC要慢，因此应该尽可能减少Full GC的次数。在对JVM调优的过程中，很大一部分工作就是对于FullGC的调节。 有如下原因可能导致Full GC： 年老代（Tenured）被写满 持久代（Perm）被写满 System.gc()被显示调用 上一次GC之后Heap的各域分配策略动态变化]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Java内存泄漏发生的情况]]></title>
      <url>%2F2015%2F08%2F26%2FJava%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E5%8F%91%E7%94%9F%E7%9A%84%E6%83%85%E5%86%B5%2F</url>
      <content type="text"><![CDATA[在Java 语言中，内存在以下情况下被回收： 1、没有任何引用指向它。 2、GC被运行。 而判断一块内存空间是否符合垃圾收集器收集标准，即没有任何引用指向它的情况有三种： 1、new了对象但是从未引用过，那么这个对象马上就会被回收。 2、给对象赋予了空值null，以下再没有调用过。 3、给对象赋予了新值，即重新分配了内存空间。 如果一块没有用的内存没有把它赋予上面2、3两种状态，那么就会造成内存泄露(无用的应该被回收的内存没有被回收)。实际编程中造成内存泄露的情况主要有以下几种： 静态集合类在使用Set、Vector、HashMap等集合类的时候需要特别注意，有可能会发生内存泄漏。当这些集合被定义成静态的时候，由于它们的生命周期跟应用程序一样长，这时候，就有可能会发生内存泄漏 12345678910class StaticTest&#123; private static Vector v = new Vector(10); public void init()&#123; for (int i = 1; i &lt; 100; i++)&#123; Object object = new Object(); v.add(object); object = null; &#125; &#125;&#125; 在上面的代码中，循环申请了Object对象，并添加到Vector中，然后将对象设置为null，可是这些对象因为被Vector引用着，因此并不能被GC回收，因此造成了内存泄漏。因此，要释放这些对象，还需要被它们从Vector删除，最简单的方法就是将Vector设置为null。 集合里的对象属性值被改变1234567891011121314151617public static void main(String[] args)&#123; Set&lt;Student&gt; set = new HashSet&lt;Student&gt;(); Student s1 = new Student("Jack"); Student s2 = new Student("Mary"); Student s3 = new Student("Eason"); set.add(s1); set.add(s2); set.add(s3); System.out.println(set.size());//3 s2.setName("Jackson"); //修改属性，此时s2元素对应的hashcode值发生改变 set.remove(s2); // remove不掉，造成内存泄漏 set.add(s2); // 添加成功 System.out.println(set.size());//4&#125; 由于对象s2的属性值被改变了，因此不能从set中删除，所以set中会一直保持着s2的引用，不能被回收，造成了内存泄漏。 监听器在Java中，我们经常会使用到监听器，如对某个控件添加单击监听器addOnClickListener()，但往往释放对象的时候会忘记删除监听器，这就有可能造成内存泄漏。好的方法就是，在释放对象的时候，应该记住释放所有监听器，这就能避免了因为监听器而导致的内存泄漏。在Android中使用setOnClickListener(null)来实现内存回收。 各种连接Java中的连接包括数据库连接、网络连接和io连接，如果没有显式调用其close()方法，是不会自动关闭的，这些连接就不能被GC回收而导致内存泄漏。一般情况下，在try代码块里创建连接，在finally里释放连接，就能够避免此类内存泄漏。 外部模块的引用调用外部模块的时候，也应该注意防止内存泄漏。如模块A调用了外部模块B的一个方法，如：public void register(Object o)这个方法有可能就使得A模块持有传入对象的引用，这时候需要查看B模块是否提供了去除引用的方法，如unregister()。这种情况容易忽略，而且发生了内存泄漏的话，比较难察觉，应该在编写代码过程中就应该注意此类问题。 单例模式使用单例模式的时候也有可能导致内存泄漏。因为单例对象初始化后将在JVM的整个生命周期内存在，如果它持有一个外部对象（生命周期比较短）的引用，那么这个外部对象就不能被回收，而导致内存泄漏。如果这个外部对象还持有其它对象的引用，那么内存泄漏会更严重，因此需要特别注意此类情况。这种情况就需要考虑下单例模式的设计会不会有问题，应该怎样保证不会产生内存泄漏问题。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Java对象初始化构造顺序]]></title>
      <url>%2F2015%2F05%2F09%2FJava%E5%AF%B9%E8%B1%A1%E5%88%9D%E5%A7%8B%E5%8C%96%E6%9E%84%E9%80%A0%E9%A1%BA%E5%BA%8F%2F</url>
      <content type="text"><![CDATA[本文讨论JAVA中对象初始化时基类子类的static field，field ，static initial block，field initial block以及Constructor的调用顺序问题，通过如下实例来说明： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758public class MyTest &#123; public static void main(String[] args) &#123; Teacher teacher = new Teacher(); &#125;&#125;class Employee &#123; private static String staticField = staticField(); private String field = print(); public Employee() &#123; System.out.println("Employee constructor"); &#125; &#123; System.out.println("Employee block"); &#125; static &#123; System.out.println("Employee static block"); &#125; private static String staticField() &#123; System.out.println("Employee static field"); return "Employee staticField"; &#125; private String print() &#123; System.out.println("Employee field"); return "Employee field"; &#125;&#125;class Teacher extends Employee &#123; private static String staticField = staticField(); private String field = print(); public Teacher() &#123; System.out.println("Teacher constructor"); &#125; &#123; System.out.println("Teacher block"); &#125; static &#123; System.out.println("Teacher static block"); &#125; private static String staticField() &#123; System.out.println("Teacher static field"); return "Teacher staticField"; &#125; private String print() &#123; System.out.println("Teacher field"); return "Teacher field"; &#125;&#125; 输出如下： 12345678910Employee static fieldEmployee static initial blockTeacher static fieldTeacher static initial blockEmployee fieldEmployee initial blockEmployee constructorTeacher fieldTeacher initial blockTeacher constructor 上面的例子说明，在初始化类的对象的时候，构造器的调用顺序： 基类的 static field 基类的 static initial block 子类的 static field 子类的 static initial block 基类的 field 基类的 initial block 基类的 constructor 子类的 field 子类的 initial block 子类的 constructor 将上述声明顺序调换，初始化的顺序依旧不变]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[编码技术总结]]></title>
      <url>%2F2015%2F02%2F28%2F%E7%BC%96%E7%A0%81%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93%2F</url>
      <content type="text"><![CDATA[名称 产生原因 字节数 说明 ASCII 初始编码，匹配英文字符 1 一共规定了127个字符的编码,32以下的被作为控制字符 扩展ASCII 加入符号字符编码 1 加入新的字母符号，还加入了很多画表格时需要用下到的横线、竖线、交叉等形状，编码到255 GB2312 汉字编码 2 一个小于127的字符的意义与原来相同，但两个大于127的字符连在一起时，就表示一个汉字。因此小于127的编码与ascii相同，一共能编码7000多个简体汉字，是最常见的汉字编码方式 GBK 扩展GB2312汉字编码容量 2 只要第一个字节是大于127就固定表示这是一个汉字的开始，不管后面跟的是不是扩展字符集里的内容(能编码20000多汉字)。向下兼容GB2312 GB18030 扩展GBK汉字编码容量，加入少数名族语言 1、2、4变长编码 单字节与 ASCII 编码兼容，双字节兼容GBK，共收录汉字70244个，还加入了少数名族语言，中国非手持和嵌入式设备的强制编码需支持标准。向下兼容GBK UTF-8 unicode的最通用的编码实现方式 1~4 根据不同的符号而变化字节长度。英文字母1个字符一个字节，汉字1个字符三个字节，从而降低了储存空间 关于Unicode存储器容量发展，产生了Unicode，目的是试图将所有语言字符编码。它废弃了以往的其他编码方式重新编码，只是一个符号集。unicode把所有语言字符全对应成两个字节的二进制数字表示，但是它没有实现编码。若字节按unicode的方式，英文字符的编码将造成极大空间浪费。 Unicode只是一个符号集，它只规定了符号的二进制代码，却没有规定这个二进制代码应该如何存储，UTF-8是Unicode常见的编码方式。 Unicode实现的几种方式： UTF-8：一个字符可以用1~4个字节表示，每次传输1个字节数据 UTF-16：一个字符可以用2个或4个字节表示，每次传输2或4个字节数据 UTF-32：一个字符可以用4个字节表示，每次传输4个字节数据 关于UTF-8 BOM头实际上，不含 BOM 的 UTF-8 才是标准形式。不同的文本编辑器对于有无BOM的称呼也略有不同，比如EditPlus，有BOM的称为UTF-8+，无BOM的称为UTF-8，而在Notepad++中，有BOM的被称为标准UTF-8，而无BOM则被称为UTF-8无BOM。 在 Windows 记事本的语境中 所谓的「ANSI」指的是对应当前系统 locale 的遗留（legacy）编码，即默认编码方式的意思。对于英文文件是ASCII编码，对于简体中文文件是GB2312编码，对于繁体中文版会采用Big5码。 所谓的「Unicode」指的是带有 BOM 的小端序 UTF-16。(UTF-8 不需要 BOM，尽管 Unicode 标准允许在 UTF-8 中使用 BOM,在网页上使用BOM是个错误) 所谓的「UTF-8」指的是带 BOM 的 UTF-8。 参考资料 http://www.zhihu.com/question/20650946http://dengo.org/archives/901]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android屏幕旋转与acticity生命周期]]></title>
      <url>%2F2015%2F01%2F25%2FAndroid%E5%B1%8F%E5%B9%95%E6%97%8B%E8%BD%AC%E4%B8%8Eacticity%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%2F</url>
      <content type="text"><![CDATA[设置 android:configChanges=&quot;orientation&quot;和不设置这个属性，生命周期表现为重新创建activity 设置 android:configChanges=&quot;orientation|keyboardHidden&quot;，在2.3上表现为不重新创建activity，5.1如下 12android:targetSdkVersion&lt;=“12”//生命周期表现为不重新创建activityandroid:targetSdkVersion&gt;”12”//表现为重新创建activity 设置 android:configChanges=&quot;orientation|keyboardHidden|screenSize&quot;，在2.3和5.1上都表现为不重新创建，在屏幕旋转时，只会调用onConfigurationChanged方法 测试代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364public class MainActivity extends Activity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.relative_center_2); Log.i("MainActivity", "执行onCreate方法"); &#125; @Override protected void onStart() &#123; super.onStart(); Log.i("MainActivity", "执行onStart方法"); &#125; @Override protected void onResume() &#123; super.onResume(); Log.i("MainActivity", "执行onResume方法"); &#125; @Override protected void onPause() &#123; super.onPause(); Log.i("MainActivity", "执行onPause方法"); &#125; @Override protected void onStop() &#123; super.onStop(); Log.i("MainActivity", "执行onStop方法"); &#125; @Override protected void onDestroy() &#123; super.onDestroy(); Log.i("MainActivity", "执行onDestroy方法"); &#125; @Override public void onConfigurationChanged(Configuration newConfig) &#123; super.onConfigurationChanged(newConfig); Log.i("MainActivity", "执行onConfigurationChanged方法"); &#125; @Override protected void onRestart() &#123; super.onRestart(); Log.i("MainActivity", "执行onRestart方法"); &#125; @Override protected void onSaveInstanceState(Bundle outState) &#123; super.onSaveInstanceState(outState); Log.i("MainActivity", "执行onSaveInstanceState方法"); &#125; @Override protected void onRestoreInstanceState(Bundle savedInstanceState) &#123; super.onRestoreInstanceState(savedInstanceState); Log.i("MainActivity", "执行onRestoreInstanceState方法"); &#125;&#125;]]></content>
    </entry>

    
  
  
</search>
